<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    .leaflet-div-icon { background: transparent; border: none; }
    /* Geohash labels: text only, no background */
    .gh-label { background: transparent; border: none; pointer-events: none; }
    .gh-text { color: #6c757d; font-weight: 600; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; font-size: 12px; line-height: 1; }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Minimal geohash implementation ported from submodule (bounds/encode/adjacent)
    (function(){
      const base32 = '0123456789bcdefghjkmnpqrstuvwxyz';
      function bounds(geohash) {
        let evenBit = true;
        let latMin=-90, latMax=90, lonMin=-180, lonMax=180;
        geohash = geohash.toLowerCase();
        for (let i=0; i<geohash.length; i++) {
          const chr = geohash.charAt(i);
          const idx = base32.indexOf(chr);
          if (idx == -1) throw new Error('Invalid geohash');
          for (let n=4; n>=0; n--) {
            const bitN = idx >> n & 1;
            if (evenBit) {
              const lonMid = (lonMin+lonMax)/2;
              if (bitN == 1) lonMin = lonMid; else lonMax = lonMid;
            } else {
              const latMid = (latMin+latMax)/2;
              if (bitN == 1) latMin = latMid; else latMax = latMid;
            }
            evenBit = !evenBit;
          }
        }
        return { sw: {lat: latMin, lng: lonMin}, ne: {lat: latMax, lng: lonMax} };
      }
      function encode(lat, lon, precision) {
        let idx=0, bit=0, evenBit=true, hash='';
        let latMin=-90, latMax=90, lonMin=-180, lonMax=180;
        while (hash.length < precision) {
          if (evenBit) {
            const lonMid=(lonMin+lonMax)/2; if (lon>=lonMid) { idx=idx*2+1; lonMin=lonMid; } else { idx=idx*2; lonMax=lonMid; }
          } else {
            const latMid=(latMin+latMax)/2; if (lat>=latMid) { idx=idx*2+1; latMin=latMid; } else { idx=idx*2; latMax=latMid; }
          }
          evenBit = !evenBit;
          if (++bit==5) { hash += base32.charAt(idx); bit=0; idx=0; }
        }
        return hash;
      }
      function adjacent(hash, dir) {
        const neighbour = {
            n: [ 'p0r21436x8zb9dcf5h7kjnmqesgutwvy', 'bc01fg45238967deuvhjyznpkmstqrwx' ],
            s: [ '14365h7k9dcfesgujnmqp0r2twvyx8zb', '238967debc01fg45kmstqrwxuvhjyznp' ],
            e: [ 'bc01fg45238967deuvhjyznpkmstqrwx', 'p0r21436x8zb9dcf5h7kjnmqesgutwvy' ],
            w: [ '238967debc01fg45kmstqrwxuvhjyznp', '14365h7k9dcfesgujnmqp0r2twvyx8zb' ],
        };
        const border = {
            n: [ 'prxz',     'bcfguvyz' ],
            s: [ '028b',     '0145hjnp' ],
            e: [ 'bcfguvyz', 'prxz'     ],
            w: [ '0145hjnp', '028b'     ],
        };
        hash = hash.toLowerCase();
        const lastCh = hash.slice(-1);
        let parent = hash.slice(0, -1);
        const type = hash.length % 2;
        if (border[dir][type].indexOf(lastCh) != -1 && parent != '') parent = adjacent(parent, dir);
        return parent + base32.charAt(neighbour[dir][type].indexOf(lastCh));
      }
      window.__geohash = { bounds, encode, adjacent };
    })();

    // Map logic
    const map = L.map('map', { zoomControl: true, minZoom: 2, maxZoom: 21 }).setView([0,0], 3);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 21, attribution: '&copy; OpenStreetMap' }).addTo(map);

    const canvasRenderer = L.canvas();
    const gridLayer = L.layerGroup().addTo(map);

    // Display precision controls what grid to render; selection holds the chosen hash
    let displayPrecision = 5;
    let center = { lat: 0, lng: 0 };
    let selectedGeohash = '';

    function notifySelection() {
      if (window.Android && window.Android.onGeohashChanged && selectedGeohash) {
        window.Android.onGeohashChanged(selectedGeohash);
      }
    }

    function drawGrid() {
      // Clear all previously drawn cells and labels in one go
      gridLayer.clearLayers();

      // Use the center and displayPrecision only for drawing the grid around
      const centerHash = window.__geohash.encode(center.lat, center.lng, displayPrecision);

      // If nothing selected yet, initialize selection to the center cell at current precision
      if (!selectedGeohash) {
        selectedGeohash = centerHash;
        notifySelection();
      }

      // Compute neighborhood around the center using BFS with bounds
      const box = { '0,0': centerHash };
      const xMin=-6, xMax=6, yMin=-5, yMax=5;
      const queue = [[0,0]];
      const visited = new Set([`0,0`]);
      const dirs = [[1,0,'e'],[-1,0,'w'],[0,1,'s'],[0,-1,'n']];
      while (queue.length) {
        const [x,y] = queue.shift();
        for (const [dx,dy,d] of dirs) {
          const nx=x+dx, ny=y+dy;
          const key = `${nx},${ny}`;
          if (nx<xMin||nx>xMax||ny<yMin||ny>yMax||visited.has(key)) continue;
          const base = box[`${x},${y}`];
          const next = window.__geohash.adjacent(base, d);
          box[key] = next;
          visited.add(key);
          queue.push([nx,ny]);
        }
      }

      for (const [coord, geohash] of Object.entries(box)) {
        const b = window.__geohash.bounds(geohash);
        const sw = [b.sw.lat, b.sw.lng], ne = [b.ne.lat, b.ne.lng];
        const isSelected = geohash === selectedGeohash;
        const rect = L.rectangle([sw, ne], {
          renderer: canvasRenderer,
          color: isSelected ? '#d63384' : '#0d6efd',
          weight: isSelected ? 3 : 2,
          fillOpacity: isSelected ? 0.25 : 0.2,
          opacity: 0.9
        });
        const opacityFalloff = 1 - (Math.abs(parseInt(coord.split(',')[0])) + Math.abs(parseInt(coord.split(',')[1]))) / 10;
        rect.setStyle({ opacity: rect.options.opacity * opacityFalloff, fillOpacity: rect.options.fillOpacity * opacityFalloff });

        rect.on('click', (e) => {
          // Prevent map click handler from also firing
          if (e) { L.DomEvent.stop(e); }
          // 1) Select exactly this quadrant's geohash (no auto sub-selection)
          selectedGeohash = geohash;
          notifySelection();

          // 2) Recenter on this cell and drill down by increasing display precision
          const b2 = window.__geohash.bounds(geohash);
          const lat = (b2.sw.lat + b2.ne.lat) / 2;
          const lng = (b2.sw.lng + b2.ne.lng) / 2;
          center = { lat, lng };
          displayPrecision = Math.min(12, geohash.length + 1);
          drawGrid();
          map.fitBounds([[b2.sw.lat, b2.sw.lng],[b2.ne.lat, b2.ne.lng]]);
        });
        rect.addTo(gridLayer);

        // Text-only label (transparent background)
        // Compute dynamic font-size relative to on-screen rectangle size
        const pSw = map.latLngToLayerPoint([sw[0], sw[1]]);
        const pNe = map.latLngToLayerPoint([ne[0], ne[1]]);
        const pxWidth = Math.abs(pNe.x - pSw.x);
        const pxHeight = Math.abs(pSw.y - pNe.y);
        const cellPx = Math.min(pxWidth, pxHeight);
        // Scale label size to fit; clamp to keep legible
        const fontSize = Math.max(10, Math.min(24, Math.floor(cellPx / 6)));
        const labelHtml = `<span class=\"gh-text\" style=\"font-size:${fontSize}px\">${geohash.toUpperCase()}</span>`;

        const labelLat = (sw[0]+ne[0])/2, labelLng=(sw[1]+ne[1])/2;
        const label = L.marker([labelLat, labelLng], {
          icon: L.divIcon({ className: 'gh-label', html: labelHtml }),
          interactive: false
        });
        label.addTo(gridLayer);


      }
    }

    // Clicking anywhere on the map (outside rectangles) should behave like selecting the cell at that point,
    // then drilling down one level, without auto-selecting a subquadrant.
    map.on('click', (e) => {
      const ghAtPoint = window.__geohash.encode(e.latlng.lat, e.latlng.lng, displayPrecision);
      selectedGeohash = ghAtPoint;
      notifySelection();

      const b2 = window.__geohash.bounds(ghAtPoint);
      const lat = (b2.sw.lat + b2.ne.lat) / 2;
      const lng = (b2.sw.lng + b2.ne.lng) / 2;
      center = { lat, lng };
      displayPrecision = Math.min(12, displayPrecision + 1);
      drawGrid();
      map.fitBounds([[b2.sw.lat, b2.sw.lng],[b2.ne.lat, b2.ne.lng]]);
    });

    function setCenter(lat, lng) {
      center = { lat, lng };
      map.setView([lat, lng], map.getZoom());
      drawGrid();
    }
    // Rescale labels on zoom so font-size tracks on-screen cell size
    map.on('zoomend', () => drawGrid());
    function setPrecision(p) { displayPrecision = Math.max(1, Math.min(12, p)); drawGrid(); }
    function getGeohash() { return selectedGeohash; }

    window.setCenter = setCenter;
    window.setPrecision = setPrecision;
    window.getGeohash = getGeohash;

    // Cleanup to release Leaflet resources when WebView is destroyed
    function cleanup() {
      try { map.off(); } catch (e) {}
      try { gridLayer.clearLayers(); } catch (e) {}
      try { map.remove(); } catch (e) {}
    }
    window.cleanup = cleanup;

    // initial draw
    drawGrid();
  </script>
</body>
</html>
